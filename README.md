# SyncCraft

SyncCraft is a lightweight Python CLI foundation for media-transcript workflows with strict test-first quality gates.

## What this repository includes

- **Core behavior modules**
  - Config merge logic (`synccraft.config`)
  - Filename templating (`synccraft.templating`)
  - Chunk planning (`synccraft.chunking`)
  - Provider adapter contract checks (`synccraft.provider`)
  - Output writing (`synccraft.output`)
  - Structured user-facing errors (`synccraft.errors`)
  - CLI entrypoint (`synccraft.cli`)

- **Test layers**
  - Unit tests (`tests/unit`)
  - Integration tests (`tests/integration`)
  - Contract tests (`tests/contract`)

- **Quality and governance**
  - CI test gates in `.github/workflows/`
  - Behavior-change test enforcement script: `scripts/check_changed_behavior_has_tests.py`
  - Contributor policy in `CONTRIBUTING.md`

## Packaging and installation

Build and installable package guidance (including runtime dependency and FFmpeg policy) is documented in [`docs/installation.md`](docs/installation.md).

To validate a local install quickly:

```bash
python -m pip install -e .
synccraft --version
```

## Development setup

### Prerequisites

- Python 3.11+

### Install

```bash
python -m pip install -e .[dev]
```

## Quickstart: first successful render in under 5 minutes

This quickstart uses repository fixtures and the `mock` provider so you can validate end-to-end behavior quickly.

1) Install SyncCraft in editable mode:

```bash
python -m pip install -e .
```

2) Create a minimal runnable config file:

```bash
cat > /tmp/synccraft.quickstart.yaml <<'YAML'
provider: mock
provider_payload: tests/fixtures/provider/success.json
output: /tmp/synccraft.quickstart.txt
YAML
```

3) Run the CLI:

```bash
synccraft \
  tests/fixtures/image/sample.png \
  tests/fixtures/audio/tone.wav \
  --config /tmp/synccraft.quickstart.yaml
```

4) Confirm output:

```bash
cat /tmp/synccraft.quickstart.txt
```

Expected result: SyncCraft prints progress events and writes a transcript file.

## Security notes

### API key storage warning

- Treat provider API keys as secrets. Do **not** commit keys to Git, paste them in issues, or hardcode them in tests.
- Prefer runtime injection (environment variables / secret manager) over static plaintext config files.
- Keep debug logs enabled only when needed. SyncCraft sanitizes key/token/password-like fields before debug logging provider payloads.

### `.gitignore` recommendations

If you create local config or runtime artifacts, ensure these patterns are ignored:

```gitignore
# Local secret-bearing config
.env
.env.*
config.local.yaml
*.secrets.yaml

# Local outputs generated by runs
out/
*.transcript.txt

# Ad-hoc debug payloads
provider_payload.local.json
```

### Environment variable best-practice examples

Use shell expansion in generated config (or your deploy tooling) so secrets are injected at runtime:

```bash
export SYNC_PROVIDER_API_KEY='***'
export SYNC_PROVIDER_ENDPOINT='https://api.example.invalid'
cat > /tmp/synccraft.secure.yaml <<'YAML'
provider: omni
output: /tmp/synccraft.out.txt
provider_params:
  api_key: ${SYNC_PROVIDER_API_KEY}
  endpoint: ${SYNC_PROVIDER_ENDPOINT}
YAML
```

For CI/CD, prefer your platform's encrypted secret store and render ephemeral config files during job execution.

## Running tests

### Full suite + coverage threshold

```bash
python -m pytest
```

### Fast unit suite (PR mandatory)

```bash
python -m pytest -m unit --no-cov
```

### Integration suite (release mandatory)

```bash
python -m pytest -m integration --no-cov
```

### Contract suite

```bash
python -m pytest -m contract --no-cov
```

### Behavior-change gate

```bash
python scripts/check_changed_behavior_has_tests.py origin/main
```

## Troubleshooting: missing `pytest-cov`

If `pytest` fails with coverage-related argument or plugin errors (for example around `--cov`), install dev dependencies so `pytest-cov` is available:

```bash
python -m pip install -e .[dev]
```

You can verify plugin availability with:

```bash
python -m pytest --help | rg -- --cov
```

## Troubleshooting runtime errors

The entries below map to current user-facing error messages emitted by the CLI.

| Scenario | Error message prefix | What to do |
| --- | --- | --- |
| Provider duration limit exceeded and no chunking configured | `what: audio duration exceeds provider limit with no chunking configured` | Add `chunk_seconds: <positive int>` in config (for example `30`) so SyncCraft can chunk long-form input. |
| Invalid config shape/content | `what: config content must be a mapping.` / `what: missing required config key: provider_payload.` / `what: missing required config key: output.` | Ensure `--config` points to a YAML object that includes `output`, and for `provider: mock`, includes `provider_payload`. |
| Missing dependency (`PyYAML`) | `what: unexpected runtime failure.; why: No module named 'yaml'` | Install package dependencies with `python -m pip install -e .` (or reinstall in a clean virtualenv). |

If needed, re-run with `--verbose` or `--debug` to get more execution detail.

## CLI usage

```bash
synccraft \
  tests/fixtures/image/sample.png \
  tests/fixtures/audio/tone.wav \
  --config ./config.yaml
```

Supported flags:

- `--verbose` (INFO logging)
- `--debug` (DEBUG logging; overrides verbose)
- `--dry-run` (validate + print summary, no provider call)
- `--version` (print version and exit immediately)


## Config examples

Example YAML configurations are provided in `docs/config.examples.yaml` for:

- minimal setup
- chunked mode
- env-var-friendly production deployment

## Architecture and extension guide (providers)

SyncCraft uses a provider adapter contract so new provider implementations can be added without changing CLI invocation shape.

Provider extension steps:

1. Implement `ProviderAdapter` (`limits()` + `generate(...)`) in `synccraft/provider.py` or a provider-specific module.
2. Return provider-neutral payloads that include `transcript`.
3. Register the adapter in `build_provider_adapter(...)` using a stable provider key.
4. Add/extend contract tests under `tests/contract` to validate shared adapter behavior.
5. Add integration coverage under `tests/integration` for end-to-end CLI flow.

For deeper boundary/layering guidance, see [`docs/architecture.md`](docs/architecture.md).

## Error contract

User-facing failures should be actionable and include:

- `what:` what failed
- `why:` why it failed
- `how-to-fix:` what to do next

## Red → Green → Refactor policy

Every behavior change should follow:

1. **Red**: add a failing test
2. **Green**: add the minimum implementation to pass
3. **Refactor**: improve design while keeping tests green

A feature PR should show test-first commit sequencing (`test:` before `feat:`).
